{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "from imblearn.over_sampling import SMOTE\n",
    "import os\n",
    "import numpy as np\n",
    "from sklearn.model_selection import KFold\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn import metrics\n",
    "import statistics\n",
    "from sklearn.metrics import classification_report\n",
    "from imblearn.over_sampling import SMOTE\n",
    "import warnings\n",
    "warnings.simplefilter('ignore')\n",
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "sns.set()\n",
    "%config InlineBackend.figure_format = 'svg'\n",
    "from pylab import rcParams\n",
    "from pandas import DataFrame\n",
    "result_file_name=\"result_file.csv\"\n",
    "result_file_path=\"path_for_result_file/\"+result_file_name\n",
    "with open(result_file_path,'w') as resultfile:\n",
    "    header='user_no,user_accu,happy_accu,sad_saccu,stress_accu,relax_accu\\n'\n",
    "    #header='Accuracy,filename,Emotion,Count\\n'\n",
    "    resultfile.write(header)\n",
    "    user_no=0\n",
    "    for root, dirs, files in os.walk(\"path_of_feature_files\"):\n",
    "        #files.remove(\".~lock.user_4_v4.csv#\")\n",
    "        \n",
    "        for filename in files:\n",
    "            url=\"path_of_feature_files/\"+filename\n",
    "            print(url)\n",
    "            \n",
    "            smote_list=[]\n",
    "            #### part1: Reading each file#########\n",
    "            dataset = pd.read_csv(url,header=None)\n",
    "        \n",
    "            array = dataset.values\n",
    "        \n",
    "            X_set=array[:,0:9] #feature values\n",
    "            Y_set=array[:,9] #emotion label\n",
    "            #print(Y_set)  \n",
    "            Y_sample=Y_set.shape[0]\n",
    "            #print(Y_sample)\n",
    "            sample_count=dict()\n",
    "            Y_series=pd.DataFrame(Y_set,columns=['0'])\n",
    "            \n",
    "            happy_set=Y_series[Y_series['0']==float(2)]\n",
    "            sad_set=Y_series[Y_series['0']==float(-2)]\n",
    "            stress_set=Y_series[Y_series['0']==float(1)]\n",
    "            relax_set=Y_series[Y_series['0']==float(0)]\n",
    "            \n",
    "            ##### part 2:SMOTE to make the data balance ###\n",
    "        \n",
    "            if(happy_set.shape[0]!=0):\n",
    "                sample_count[float(2)]=happy_set.shape[0]\n",
    "                smote_list.append(happy_set.shape[0])\n",
    "            if(sad_set.shape[0]!=0):\n",
    "                sample_count[float(-2)]=sad_set.shape[0]\n",
    "                smote_list.append(sad_set.shape[0])\n",
    "            if(stress_set.shape[0]!=0):\n",
    "                sample_count[float(1)]=stress_set.shape[0]\n",
    "                smote_list.append(stress_set.shape[0])\n",
    "            if(relax_set.shape[0]!=0):\n",
    "                sample_count[float(0)]=relax_set.shape[0]\n",
    "                smote_list.append(relax_set.shape[0])\n",
    "            \n",
    "            #sample_count=list(filter(lambda a: a != 0, sample_count))\n",
    "            \n",
    "            value_cond=0\n",
    "            for name, value in sample_count.items():\n",
    "                if(value==1):\n",
    "                    value_cond=value\n",
    "            if(value_cond==1):\n",
    "                    print(filename)\n",
    "            else:\n",
    "                \n",
    "                print(sample_count) \n",
    "                min_count=min(smote_list)\n",
    "                smote_dict=dict()\n",
    "                length_count=len(sample_count)\n",
    "                #for i in range(length_count-1):\n",
    "                min_key=min(sample_count, key=lambda k: sample_count[k])\n",
    "                min_Key_value=sample_count[min_key]\n",
    "                del sample_count[min_key]\n",
    "                d = dict((k, v) for k, v in sample_count.items() if v > min_Key_value)\n",
    "                #print(d)\n",
    "                min_value_d=d[min(d, key=lambda k: d[k])]\n",
    "                smote_dict[min_key]=min_value_d\n",
    "                print(smote_dict) \n",
    "                \n",
    "                sm=SMOTE(smote_dict,random_state=2,k_neighbors=min_count-1)\n",
    "                X_res, Y_res = sm.fit_sample(X_set, Y_set.ravel()) \n",
    "                # X_res(Feature value) and Y_res(emotion label) is my new data after SMOTE######\n",
    "                \n",
    "                \n",
    "                "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
